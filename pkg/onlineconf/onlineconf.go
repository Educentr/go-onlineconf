package onlineconf

// Package onlineconf reads configuration files generated by OnlineConf.
//
// It opens indexed CDB files and maps them in the memory.
// If OnlineConf modifies them then they are automatically reopened.

import (
	"context"
	"fmt"
	"log"
	"path"
	"sync"

	"github.com/Nikolo/go-onlineconf/pkg/onlineconfInterface"
	"github.com/fsnotify/fsnotify"
	"golang.org/x/exp/mmap"
)

var initMutex sync.Mutex

// Initialize sets config directory for onlineconf modules.
func Create(options ...onlineconfInterface.Option) onlineconfInterface.Instance {
	initMutex.Lock()
	defer initMutex.Unlock()

	logger := &DefaultLogger{}

	inst := &OnlineconfInstance{
		logger:       logger,
		byName:       make(map[string]onlineconfInterface.Module),
		byFile:       make(map[string]onlineconfInterface.Module),
		names:        make([]string, 0, startModuleCountSize),
		configDir:    defaultConfigDir,
		mmappedFiles: make(map[string]*mmapedFiles, startModuleCountSize),
	}

	for _, opt := range options {
		opt.Apply(inst)
	}

	return inst
}

func (oi *OnlineconfInstance) GetModuleNames() []string {
	oi.Lock()
	defer oi.Unlock()

	return oi.names
}

func (oi *OnlineconfInstance) GetConfigDir() string {
	return oi.configDir
}

func (oi *OnlineconfInstance) RegisterSubscription(module string, params []string, callback func() error) error {
	if oi.ro {
		return ErrUnavailableInRO
	}

	mod, ex := oi.byName[module]
	if !ex {
		return fmt.Errorf("can't register callback for module %s. Module does not exists", module)
	}

	mod.RegisterSubscription(NewSubscription(params, callback))

	return nil
}

func (oi *OnlineconfInstance) StartWatcher(ctx context.Context) error {
	if oi.ro {
		return ErrUnavailableInRO
	}

	log.Printf("StartWatcher: %s", oi.configDir)
	if err := oi.watcher.start(oi.configDir, oi.watcherCallback(ctx), func(err error) { oi.logger.Error(ctx, "watcher error", err) }); err != nil {
		return fmt.Errorf("can't start watcher: %w", err)
	}

	return nil
}

func (oi *OnlineconfInstance) StopWatcher() error {
	if oi.ro {
		return ErrUnavailableInRO
	}

	if err := oi.watcher.stopWatcher(); err != nil {
		return fmt.Errorf("can't stop watcher: %w", err)
	}

	return nil
}

func (oi *OnlineconfInstance) incRefcount(mmappedFile *mmap.ReaderAt) error {
	if oi.ro {
		return ErrUnavailableModifyRefcountRO
	}

	addrMmapedFile := fmt.Sprintf("%p", mmappedFile)

	if _, ex := oi.mmappedFiles[addrMmapedFile]; !ex {
		oi.mmappedFiles[addrMmapedFile] = &mmapedFiles{
			reader:   mmappedFile,
			refcount: 0,
		}
	}

	oi.mmappedFiles[addrMmapedFile].refcount++

	return nil
}

func (oi *OnlineconfInstance) decRefcount(mmappedFile *mmap.ReaderAt) error {
	if oi.ro {
		return ErrUnavailableModifyRefcountRO
	}

	addrMmapedFile := fmt.Sprintf("%p", mmappedFile)

	if _, ex := oi.mmappedFiles[addrMmapedFile]; !ex {
		return fmt.Errorf("can't found decRefcount for mmap %s", addrMmapedFile)
	}

	oi.mmappedFiles[addrMmapedFile].refcount--

	if oi.mmappedFiles[addrMmapedFile].refcount == 0 {
		oi.mmappedFiles[addrMmapedFile].reader.Close()
		delete(oi.mmappedFiles, addrMmapedFile)
	}

	return nil
}

func (oi *OnlineconfInstance) watcherCallback(ctx context.Context) func(ev fsnotify.Event) {
	if oi.ro {
		panic("unable to use watcherCallback in readonly instance")
	}

	return func(ev fsnotify.Event) {
		if ev.Op&fsnotify.Create == fsnotify.Create {
			initMutex.Lock()
			defer initMutex.Unlock()

			module, ok := oi.GetModuleByFile(ev.Name)
			if ok {
				mmappedFile, err := oi.openMmapFile(ev.Name)
				if err != nil {
					oi.logger.Error(ctx, "error mmap open module:", err)
					return
				}

				oldMmaped, err := module.Reopen(mmappedFile)

				if err != nil {
					oi.decRefcount(mmappedFile)
					oi.logger.Error(ctx, "error inc refcunt mmap:", err)
					return
				}

				oi.decRefcount(oldMmaped)
			}
		}
	}
}

func (oi *OnlineconfInstance) openMmapFile(path string) (*mmap.ReaderAt, error) {
	if oi.ro {
		return nil, ErrUnavailableInRO
	}

	mmappedFile, err := mmap.Open(path)
	if err != nil {
		return nil, fmt.Errorf("mmap Open error: %w", err)
	}

	if err := oi.incRefcount(mmappedFile); err != nil {
		mmappedFile.Close()
		return nil, fmt.Errorf("error inc refcount mmap: %w", err)
	}

	return mmappedFile, nil
}

func (oi *OnlineconfInstance) GetModuleByFile(fileName string) (onlineconfInterface.Module, bool) {
	if oi.ro {
		// don't copy for faster
		panic("unable to use GetByFile in readonly instance")
	}

	oi.Lock()
	defer oi.Unlock()

	m, ex := oi.byFile[fileName]

	return m, ex
}

// GetModule returns a named module.
func (oi *OnlineconfInstance) GetModule(name string) onlineconfInterface.Module {
	oi.Lock()
	defer oi.Unlock()

	if module, ok := oi.byName[name]; ok {
		return module
	}

	return nil
}

// GetModule returns a named module.
func (oi *OnlineconfInstance) GetOrAddModule(name string) (onlineconfInterface.Module, error) {
	oi.Lock()
	defer oi.Unlock()

	if module, ok := oi.byName[name]; ok {
		return module, nil
	}

	if oi.ro {
		return nil, fmt.Errorf("unable to Add module %s in readonly instance. If you want to use this module please open it on main instance", name)
	}

	filename := path.Join(oi.configDir, name+".cdb")

	ocModule := &Module{name: name, filename: filename}

	mmapedFile, err := oi.openMmapFile(filename)
	if err != nil {
		return nil, err
	}

	oi.byFile[filename] = ocModule
	oi.byName[name] = ocModule
	oi.names = append(oi.names, name)

	if _, err = ocModule.Reopen(mmapedFile); err != nil {
		return nil, fmt.Errorf("error add module: %w", err)
	}

	return ocModule, nil
}

func (oi *OnlineconfInstance) Clone() (onlineconfInterface.Instance, error) {
	if oi.ro {
		return nil, fmt.Errorf("can't clone RO instance")
	}

	existsModules := oi.names

	newInstance := &OnlineconfInstance{
		ro:     true,
		logger: oi.logger,
		byName: make(map[string]onlineconfInterface.Module, len(existsModules)),
		names:  oi.names,
	}

	initMutex.Lock()
	defer initMutex.Unlock()

	for _, name := range existsModules {
		m := oi.GetModule(name)
		if m == nil {
			return nil, fmt.Errorf("module %s not found", name)
		}

		if err := oi.incRefcount(m.GetMmappedFile()); err != nil {
			return nil, err
		}

		newInstance.byName[name] = m.Clone(name)
	}

	return newInstance, nil
}

func (oi *OnlineconfInstance) Release(cloned onlineconfInterface.Instance) error {
	if oi.ro {
		return fmt.Errorf("invalid main instance (RO)")
	}

	clonedInstance, ok := cloned.(*OnlineconfInstance)
	if !ok {
		return fmt.Errorf("invalid cloned instance")
	}

	initMutex.Lock()
	defer initMutex.Unlock()

	for _, name := range clonedInstance.GetModuleNames() {
		m := cloned.GetModule(name)
		oi.decRefcount(m.GetMmappedFile())
	}

	clonedInstance.names = []string{}
	clonedInstance.byFile = map[string]onlineconfInterface.Module{}
	clonedInstance.byName = map[string]onlineconfInterface.Module{}

	return nil
}
